学习原因:
对多线程有一定的理解,但是又不够系统,深入,全面
学习目的:
1.加强自己对多线程相关知识的理解和运用
2.边学习,边做笔记,方便以后温习
3.提炼书中的重点,佐以代码说明

书译量很不错,建议大家有空可以直接阅读原文

第一章 简介:
线程的优势:
1.发挥多处理器的强大能力
2.建模的简单性
3.异步事件的简化处理
4.响应更灵敏的用户界面

线程带来的风险:
1.安全性问题(永远不会发生糟糕的事情)
2.活跃性问题(正确的事情最终会发生):死循环,死锁,饥饿,活锁
3.性能问题(正确的事情尽快发生):线程切换开销大


---------------------------------


第二章 线程安全性:
1.编写线程安全的代码,其核心在于 要对状态访问操作进行管理,特别是对共享的,和可变的状态的访问
2.要使得对象是线程安全的,需要采用同步机制来协同对象可变状态的访问
3.当多个线程访问一个可变的状态变量时没有使用合适的同步,那么程序就会出现错误,有三种方式可以修复这个问题
    1.不在线程之间共享该状态变量
    2.将状态变量修改为不可变的变量
    3.在访问状态变量时使用同步

java中的主要同步机制是synchronized

什么是线程安全性:
1.线程安全的的核心的概念就是正确性,正确性的含义就是:某个类的行为与规范完全一致
2.当多个线程访问某个类时,这个类始终都能表现出正确的行为,那么这个类就是线程安全的
3.无状态对象一定是线程安全的

竞态条件:
当某个计算的正确性取决于多个线程的交替执行时序时,那么就会发生竞态条件

java 内置锁:
同步代码块(Synchronized Block):包含两部分,一个作为锁的引用对象,一个作为由这个锁保护的代码块
非static方法是用synchronized修饰,锁的是当前类的实例
static方法是用synchronized修饰,锁的是当前类


-------------------------------------


第三章 对象的共享:
可见性:
通常,我们无法确保执行读操作的线程能适时的看到其他线程写入的值
只要有数据在多个线程中共享,就使用正确的同步

非原子的64位操作:
当线程在没有同步的情况下读取变量时,可能会得到一个失效的值,但至少这个值是由之前某个线程设置的值,而不是一个随机值.这种安全性保证也被称为最低安全性
最低安全性适用于绝大多数变量,但是存在一个例外:非volatile类型的64位数值变量

java内存模型要求,变量的读取和写入操作必须是原子操作,但是对于非volatile类型的long的double变量,jvm允许将64位的读操作或写操作分解为两个32位的操作.
当读取一个非volatile类型的long变量时,如果对该变量的读操作和写操作在不同的线程中执行,那么很可能会读到某个值的高32位和另一个值的低32位,因此
即使不考虑失效数据问题,在多线程程序中使用共享且可变的long和double等类型的变量也是不安全的,除非使用volatile关键字来声明它们,或者用锁保护起来

volatile变量
1.有序性:不会重排序
2.可见性:总是能读取到最新的值

建议使用volatile变量的条件:
1.对变量的写入不依赖变量的当前值,或者只有单个线程更新变量的值
2.该变量不会与其它状态变量一起纳入不变性条件中
3.在访问变量时不需要加锁


发布与逸出
发布:使对象能够在当前作用域之外的代码中使用
逸出:当某个不应该被发布的对象被发布时


线程封闭
仅在单线程内访问数据,它是实现线程安全最简单的方式之一


ad-hoc线程封闭
维护线程封闭性的职责完全由程序来承担
在volatile存在一种特殊的线程封闭,只要确保只有一个线程对volatile变量进行写入操作,那么就可以安全的在这个变量上执行 读取,修改,写入 操作
大多数GUI框架都是单线程


栈封闭
栈封闭是线程封闭的一种特列,在线程封闭中,只能通过局部变量才能访问对象,栈封闭比ad-hoc更易于维护,更健壮


ThreadLocal
提供get和set等方法,为每个使用该变量的线程都存有一份独立的副本


不可变
如果某个对象在创建之后,其状态就不能被修改,那么这个对象就被成为不可变对象
不可变对象一定是线程安全的
即使对象的所有域都是都是final类型的,这个对象也仍然是可变的,因为在final的域中可以可以保存对可变对象的引用

当满足以下条件时,对象才是不可变的:
1.对象创建以后其状态就不能修改
2.对象的所有域都是final类型的
3.对象时正确创建的(没有this引用逸出)


final域
用于构造不可变对象(如果final域所引用的对象是可变的,那么这些被引用的对象是可以修改的)
在java内存模型中,final域能够确保初始化的安全性,从而可以不受限制的访问不可变对象,并在共享这些对象时,无须同步

安全发布
任何线程都可以在不需要额外同步的情况下安全的访问不可变对象,即使在发布这些对象时没有使用同步

要安全的发布一个对象,对象的引用及对象的状态必须同时对其他线程可见,一个正确构建对象可以通过以下几种方式发布
1.在静态初始化函数中初始化一个对象引用
2.将对象的引用保存到volatile类型的域或者AtomicReferance对象中
3.将对象的引用保存到某个正确构造对象的final类型域中
4.将对象的引用保存到一个由锁保护的域中

事实不可变对象
如果对象从技术上说是可变的,但其状态在发布后就不会再改变,那么把这种对象称为"事实不可变状态"
在没有额外同步的情况下,任何线程都可以安全的使用被安全发布的事实不可变对象

可变对象
如果对象在构造后可以修改,那么安全发布只能确保"发布当时"状态的可见性

对象的发布需求取决于它的可变性
1.不可变对象可以通过任意机制来发布
2.事实不可变对象必须通过安全方式来发布
3.可变对象必须通过安全方式来发布,并且必须是线程安全的或者由某个锁保护起来

在并发程序中使用和共享对象时,可以使用一些实用的策略
线程封闭:线程封闭的对象只能由一个对象拥有,对象被封闭在该线程中,并且只能由这个线程修改
只读共享:在没有额外同步的情况下,共享的只读对象可以由多个线程并发访问,但任何线程都不能修改它,共享的只读对象包括不可变对象和事实不可变对象
线程安全共享:线程安全的对象在其内部实现同步,因此多个线程可以通过对象的共有接口来进行访问而不需要进一步的同步
保护对象:被保护的对象只能通过持有特定的锁来访问,保护对象包括封装在其他线程安全对象中的对象,以及已发布的并且由某个特定锁保护的对象


---------------------------------------------


第四章 对象的组合:
在设计线程安全的类的过程总中,需要包含以下三个基本要素
1.找出构成对象的所有变量
2.找出约束状态变量的不变性条件
3.建立状态对象的并发访问管理策略

收集同步需求

实例封闭
封装简化了线程安全类的实现过程,它提供了一种实例封闭机制
将数据封装在对象内部,可以将对数据的访问限制在对象的方法上,从而更容易确保线程在访问数据时总能持有正确的锁

监视器模式
把对象的所有可变状态都封装起来,并由对象自己的内置锁来保护(不是使用当前类的实例作为锁)

SimpleDateFormat 是非线程安全的


第五章 基础构建模块:
同步容器类:
Vector和Hashtable
通过 Collections.synchronizedXxx 创建的容器类

同步容器类的问题:
同步容器类都是线程安全的,但在某些情况下可能需要额外的客户端加锁来保护复合操作
常见的复合操作:迭代,跳转(根据指定顺序找到当前元素的下一个元素),条件运算(例如:若没有则添加)

迭代器与ConcurrentModificationException
当容器在迭代的过程中被修改时,就会抛出一个ConcurrentModificationException
这个异常并不是一个完备的处理机制,它只是善意的捕获并发错误,只能作为并发问题的预警器,而且它检测是否被修改的过程也是在没有同步的情况下进行的
想要避免出现 就会抛出一个ConcurrentModificationException ,就必须在迭代过程中持有容器的锁
如果不希望在迭代期间对容器加锁,另一种方式替代方案就是克隆容器(CopyOnWrite),并在副本上进行迭代副本被封闭在线程内,克隆容器时,存在显著的性能开销

并发容器:
ConcurrentHashMap
与HashMap一样,ConcurrentHashMap也是一个基于散列的Map,并不是将每一个方法都在同一个锁上同步使得每次只有一个线程访问容器,而是使用一种
粒度更细的加锁机制来实现更大程度的共享,这种机制称为分段锁
在并发的环境下有更高的吞吐量,在单线程的环境下只损失非常小的性能
不会抛出ConcurrentModificationException

ConcurrentMap
提供一些常见的原子复合操作,例如,若没有则添加,若相等则移除等

CopyOnWriteArrayList
CopyOnWriteArrayList用于替代同步List,在迭代期间不需要对容器进行加锁或复制
(类似的,CopyOnWriteArraySet用于替代Set)
写入时复制容器的线程安全性在于,只要正确的发布一个事实不可变对象,那么访问该对象时,就不需要进一步的同步
每次修改时,都会创建并重新发布一个新的容器副本,从而实现可变性
当迭代操作远远多于写入操作,才应该使用写入时复制容器

阻塞队列和生产者消费者模式
阻塞队列提供了可阻塞的put和take方法,以及支持定时的offer和poll.如果队列已经满了,那么put方法将阻塞直到有空间可用;
如果队列为空,那么take方法将会阻塞到有元素可用.队列可以有界的也可以是无界的.无界队列永远都不会充满,因此无界队列上的
put方法也永远不会阻塞

在类库中包含了BlockingQueue(阻塞队列)的多种实现,其中,LinkedBlockingQueue和ArrayBlockingQueue是FIFO队列,二者
分别与LinkedList和ArrayList类似,但是比同步List拥有更好的并发性能
PriorityBlockingQueque是一个按优先级排序的队列
SynchronousQueue实际上它不是一个真正的队列,因为它不会为队列中的元素维护存储空间,与其他队列不同的是,它维护一组线程

闭锁 CountDownLatch 和 FutureTask
闭锁是一种同步工具类,可以延迟线程的进度直到其到达终止状态
闭锁的作用相当于一扇门:在闭锁到达结束状态之前,这扇门一直是关闭的.并且没有任何线程能通过,当到达结束状态时,这扇门会打开
并允许所有的线程通过.当闭锁到达结束状态后,将不会再改变状态

CountDownLatch是一种灵活的闭锁实现,它可以使一个或多个线程等待一组事件发生

FutureTask 也可以用作闭锁


信号量 Semaphore
计数信号量用来控制同时访问某个特定资源的操作数量,或者同时执行某个指定操作的数
Semaphore中管理着一组虚拟的许可,许可的初始数量可通过构造函数来指定.在执行操作时可以首先获得许可,并在使用以后释放许可
如果没有许可,那么acquire将阻塞直到有许可.release方法返回一个许可给信号量


栅栏 CyclicBarrier和Exchanger
栅栏类似于闭锁,他能阻塞一组线程直到某个事件发生.栅栏与闭锁的关键区别在于,所有线程必须同时到达栅栏位置,才能继续执行
闭锁用于等待事件,而栅栏用于等待其他线程

Exchanger
它是一种两方栅栏,各方在栅栏位置上交换数据.当两方执行不对称操作时,Exchanger会非常有用

第一部分小结:
1.可变状态是至关重要的,所有的并发问题都可以归结为如何协调对象并发状态的访问,可变状态越少,就越容易保证线程安全
2.尽量将域声明为final类型,除非需要他们是可变的
3.不可变对象一定是线程安全的
4.封装有助于管理复杂性
5.用锁保护每个可变变量
6.当保护同一个不变性条件中的所有变量时,需要使用同一个锁
7.在执行复合操作期间,要持有锁
8.如果从多个线程中访问同一个可变变量时没有使用同步机制,那么程序会出现问题.
9.不要故作聪明的推断出不需要使用同步
10.在设计过程中考虑线程安全,或者在文档中明确的指出它不是线程安全的
11.将同步策略文档化


----------------------------------------------------


第六章 任务执行

Executor框架
它提供了一种标准的方法将任务的提交过程与执行过程解耦开来,并用Runnable来表示任务

执行策略
通过将任务的体骄傲与执行解耦开来,从而无需太大的困难就可以为某种类型的任务指定和修改执行策略

线程池
管理一组同构工作线程的资源池

newFixedThreadPool
创建一个固定长度的线程池,每当提交一个任务时就创建一个线程,直到达到线程池的最大数量,
这时线程池的规模将不再变化

newCachedTreadPool
创建一个可缓存的线程池,如果线程池的当前规模超过了处理需求时,那么将回收空闲的额线程,
而当需求增加时,则可以添加新的线程,线程池的规模不存在任何限制

newSingleThreadExecutor
创建单个工作者线程来执行任务,如果这个线程异常结束,会创建另一个线程来替代.
它还能确保依照任务在队列中的的顺序来串行执行(FIFO,LIFO,优先级)

newScheduledThreadPool
创建一个固定长度的线程池,而且以延迟或定时的方式来执行任务,类似于Timer

Executor生命周期
为了解决执行服务生命周期的问题,Executor扩展了ExecutorService接口,
添加了一些用于生命周期管理的方法

ExecutorService的生命周期有三种状态,运行,关闭,和已终止

shutdown方法将执行平缓的关闭过程:不再接受新的任务,同时等待已经提交的任务执行完成,包括还未开始执行的任务

shutdownNow方法将执行粗暴的关闭过程:它将尝试取消所有运行中的人物,并且不再启动队列中尚未开始执行的任务


携带结果的任务Callable与Future
Callable :他认为主入口点将返回一个值,并可能抛出一个异常

Fature :表示一个任务的生命周期,并提供了相应的方法来判断是否已经完成或取消

CompletionService :
CompletionService将Excutor与BlockingQueue的功能融合在一起
将Callable任务提交给它来执行,然后使用类似于队列操作的take和poll等方法来获得已完成的结果


------------------------------------------------


第七章 取消与关闭:
java没有提供任何机制来安全的终止线程.但它提供了中断,这是一种协作机制,能够使一个线程终止另一个线程的当前工作

任务取消
如果外部代码能够在某个操作正常完成之前将其置入为 "完成" 状态,那么这个操作就是可取消的
java中没有一种安全的抢占式方法来停止线程.因此也就没有安全的抢占式方式来停止任务.
只有一些协作式的机制,使请求取消的任务和代码都遵循一种协商好的协议

中断
线程中断是一种协作机制,线程可以通过这种机制来通知另一个线程,告诉他在合适的或者可能的情况下,停止当前工作,转而执行其他的工作
它并不会真正的中断一个正在运行的线程,而只是发出中断请求,然后由线程在下一个合适的时刻中断自己

通常,中断是实现取消的最合理方式

由于每个线程拥有各自的中断策略,因此除非你知道中断对该线程的含义,否则就不应该中断这个线程

响应中断
有两种策略可用于处理InterruptedException
1.传递异常,从而使你的方法也可以成为中断的阻塞方法
2.恢复中断状态,从而使调用栈的上层代码能够对其进行处理

通过Future来实现取消
ExecutorService.submit将返回一个Furture来描述任务.Futrue拥有一个cancel方法,
该方法带有一个boolean类型的参数mayInterruptIfRunning,表示取消操作

处理不可中断的阻塞
对于那些由于执行不可中断操作而被阻塞的线程,可以使用类似中断的手段来停止这些线程,但这要求我们必须知道线程阻塞的原因

毒丸 对象
关闭生产者消费者服务的方式之一就是使用毒丸对象:毒丸 是指一个放在队列上的对象,其含义是,当得到这个对象时,立即停止



第八章 线程池的使用
虽然Executor框架为制定和修改执行策略都提供了相当大的灵活性,但并非所有的任务都能适用所有的执行策略.
有些类型的任务需要明确的指定执行策略,包括:
1.依赖性任务
2.使用线程封闭机制的任务
3.对响应时间敏感的任务
4.使用ThreadLocal的任务

只有当任务都是相同类型的并且相互独立时,线程池的性能才能达到最佳

线程饥饿死锁
如果所有正在执行任务的线程都由于等待其他仍处于工作队列中的任务而阻塞,这种现象称为线程饥饿死锁

配置ThreadPoolExecutor
ThreadPoiolExecutor为一些Executor提供了基本实现,这些Executor是由Executors中的newCachedThreadPool,
newFixedThreadPool和newScheduledThreadExecutor等工厂方法返回的.ThreadPoolExecutor是一个灵活的
,稳定的线程池,允许各种定制

ThreadPoolExecutor通用构造
public ThreadPoolExecutor(int corePoolSize,//线程池基本大小
                          int maximumPoolSize,//线程池最大大小
                          long keepAliveTime,//存活时间
                          TimeUnit unit,//时间单位
                          BlockingQueue<Runable> workQueue,//工作队列
                          ThreadFactory threadFactory,//
                          RejectedExecutionHandler handler) //

1.线程的创建和销毁;corePoolSize,maxinumPoolSize,keepAliveTime,unit
2.管理队列任务:workQueue
3.饱和策略:handler
4.线程工厂:threadFactory

为什么GUI是单线程的:多线程的GUI容易引发死锁问题


---------------------------------


第十章 避免活跃性危险

死锁
当一个线程永远的持有一个锁,并且其他线程都尝试获得这个锁时,那么它们将永远被阻塞
线程a持有l并想获得锁m的同时,线程持有了锁m并尝试获得锁l那么这两个线程将永远的等下去.
这种情况就是最简单的死锁形式,或者称为抱死

数据库系统设计中考虑了监测死锁以及从死锁中恢复,当检测到一组事务发生死锁时,将选择一个
牺牲者并放弃这个事务

锁顺序死锁
两个线程试图以不同的顺序来获得相同的锁,就会发生锁顺序死锁
如果按照相同的顺序来请求锁,那么就不不会出现循环的加锁依赖性,因此就不会产生死锁
要想验证锁顺序的一致性,需要对程序中的加锁行为进行全局分析

动态的锁顺序死锁

在协作对象之间发生的死锁

开放调用(不要同时锁定多个对象,采用一个接一个的锁定方式)
如果在调用某个方法时不需要持有锁,那么这种调用被称为开放调用

死锁的避免
1.如果一个程序每次至多至多只能获得一个锁(开放调用,最好的方式),那么就不会产生锁顺序死锁
2.如果必须获取多个锁,在设计时必须考虑锁的顺序
3.显式的使用Lock类中的定时tryLock功能来代替内置锁机制

死锁的诊断
使用线程转储(Thread Dump)来帮助识别死锁的发生

其他活跃性危险
饥饿:当线程由于访问它所需要的资源而不能继续执行时,就发生了饥饿
活锁:当多个相互协作的线程都对彼此进行响应从而修改各自的状态,并使得任何一个线程都无法继续执行时,就发生了活锁



------------------------------------


第十一章 性能与可伸缩性
对性能的思考:
要想通过并发来获得更好的性能,需要努力做好两件事情:
1.更有效的利用现有处理资源
2.再出现新的处理资源时使程序尽可能的利用这些新资源

可伸缩性指的是:
当增加计算资源时(例如CPU,内存,存储容量或者I/O带宽),程序的吞吐量或者处理能力能相应的增加

Amdahl定律
在增加计算资源的情况下,程序在理论上够实现最高加速比

线程引入的开销:
1.上下文切换
2.内存同步
3.阻塞


减少锁的竞争
在并发程序中,对可伸缩性的最主要的威胁就是独占方式的资源锁
1.缩小锁的范围(快进快出)
2.减小锁的粒度:降低线程请求锁的频率
3.锁分段:对一组独立对象上的锁进行分解
4.避免热点域
5.一些替代独占锁的方法(并发容器,读写锁,不可变对象,原子变量(cas))
6.监测cup的利用率
7.向对象池说不

减少上下文的开销:



































































